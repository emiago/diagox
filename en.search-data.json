{"/diagox/blog/":{"data":{"":"\nWelcome to blog where you can find some interesting topics or how to use some of VOIP stack features. NOTE: this may not reflect current change of stack so always check with latest documentation."},"title":"_index"},"/diagox/docs/":{"data":{"":"Welcome to diagox documentation!.","features#Features":" Call bridging as B2B that performs SIP topology hiding Integrated Registrar to allow user (SIP phones) registering and discovery Media proxy that avoids transcoding and therefore saves your CPU and costs Call Rate Limiting / Inbound + Outbound Simple routing and matching for easier handling hundreds of different routes Built IN Fallback routing based on SIP Response when Carrier/Endpoint start to reject Endpoint IP/Auth identification SIP/WEBRTC bridging for Browser clients Call History with SIP Trace, RTCP metrics and Quality calculations based on networking Call Recording to WAV format / as interleaved mixed stereo streams which is great for Transcription Configuration validation on bootstrap Structured logging as JSON for easier integration with Cloud tools NEXT: -\u003e Install","what-is-diagox#What is Diagox?":"Diagox is modern approach for your cloud VOIP SIP/RTP/WEBRTC Ingress service, built on top of sipgo and diago library.\nIt is main purpose todo easy routing and bridging to allow you to scale internal API/VOIP services."},"title":"_index"},"/diagox/docs/agent_rpc/":{"data":{"":"","#":"","agent-requests#Agent requests":"ring Starts ring with SIP 180.\nanswer Answers call and voice media is established.\nplay Playing file or url.\nPayload:\nuri - Uri format for playing wav files file: file://somefile.wav - Files by default are looked relative to diagox executable or configured Playback Dir http: https://mycoolfiles/sound.wav read_dtmf Reading DTMF. Payload:\nduration_sec - how long to wait for dtmf(s) in seconds termination - stop on this termination digit hangup Hangups a call.\nredirect Redirects call to endpoint, after which call control is terminated. Payload","diagox-requests#Diagox requests":"For incoming call Diagox will send invite request for agent to accept or not. In case of not accepting depending on response diagox can send this invite to other agent if loadbalancing is in place.\nWhen call is hanguping or being redirected bye will be sent as final request. Generally Agent should just respond 200 but it will hold up call untill this happens.\ninvite New call session initiated. Must be accepted by agent with 200 OK or rejected or redirected.\nPayload:\ncallID - SIP callID of dialog. Useful for tracing from - From number or SIP From header user part to - To number or SIP To header user part bye Indication that call is exiting either due to remote hangup, agent hangup or redirect.","protocol#Protocol":" NOTE: Feature is in Experimental stage and design may change!\nAgent RPC Protocol tries to give users way to control routing of call in more programable manner with some limited set of APIs\nAgent RPC is JSON protocol over Websocket and it is very close to SIP as it is all based on Request/Response transactions. This makes a bit more easier to handle sessions and reason about, instead inventing some totally different protocol.\nUnlike some other systems it is designed as well that you can achieve redundancy or even load balancing. So\nUse cases API allows very simple actions and mainly intention is that you are able to influence on the routing of call. Here are some use cases that we find useful:\nCreating complex routing that needs more authentication or identification of user Simulation Agents for call testing by connecting to diagox server, like checking networking or similar. Quick IVR or Auth system based on DTMF input Delaying call routing while playing some Playbacks Autoscaling underhood systems Protocol Protocol is request/response transactions as P2P communication.\nAll transactions/sessions are multiplexed over single WS connection, but to make this easier, SDKs will be provided\nSDKs supported: NodeJS - diagox-agent-sdk-js Go - TODO Connecting Agent must connect (we may implement other way arround) to websocket server on port (default) 6000, and use endpoint parameter for endpoint unique name.\nExample with wscat tool: wscat --connect ws://localhost:6000\\?endpoint=myagent\nNOTE: DO NOT EXPOSE THIS PORT as there is no yet auth system.\nYou can connect many agents with same endpoint ID, where in this case traffic will be randomly load balanced.\nExample Here simple use case of answering a call and running playback and redirecting\nDiagox has endpoint myagent and voicebot configuration for routing:\nendpoints: incoming: match: type: \"ip\" values: [\"10.10.0.1/24\"] voicebot: # Address of record uri: \"sip:voicebot:5080\" myagent: match: type: \"agent\" ","requestsresponses#Requests/Responses":"Request fields:\nid - unique id of request did - dialog id op - operation or name of request data - payload object Response fields:\nid - unique id of request did - dialog id code - 100-600 status codes reason - Status code reason data - payload object Response can be\n100 - 200 as Provisional. This are mostly informational for request that need to take time to complete like playing a file 200 - 600 as Final Example\n// Request { \"id\": \"8a4d9f5e-2b63-4854-82be-9f24b25d9d93\", \"did\": \"dea5aa08-f964-434b-92b5-7fc75cf4662b__734dee05-fcd9-4067-85ac-7ccaf81c1544__JraXcfuPG77WpJt2\", \"op\": \"invite\", \"data\": null } // Response { \"id\": \"8a4d9f5e-2b63-4854-82be-9f24b25d9d93\", \"did\": \"dea5aa08-f964-434b-92b5-7fc75cf4662b__734dee05-fcd9-4067-85ac-7ccaf81c1544__JraXcfuPG77WpJt2\", \"code\": 200, \"reason\": \"OK\" \"data\": null } "},"title":"Agent RPC Protocol"},"/diagox/docs/call_history/":{"data":{"":"","#":"Monitoring your traffic is important. Although there are several ways to monitor SIP traffic, Diagox exposes Call History with GUI and API to make this more accurate and easier.\nasds\nNOTE By default it uses in memory storage. In multi node setups it requires external storage like Redis or MySQL.\nGUI It provides full monitoring of Calls(Dialogs) and easy access to SIP traces and Recordings( If enabled! ). Additionally based on media traffic it tries to give some score on your Call Quality called MES (influenced on Asterisk MES) which is based on RTCP reports and values like jitter, rtt, packet loss etc. You can find this values as well when clicking any record. API You can build your own interface using API.\nPath Description GET /api/v1/history Read call recordings with Media stats More you can find in Open API Yaml"},"title":"Call history"},"/diagox/docs/install/":{"data":{"":"Supported arch:\nLinux amd64 Linux arm64 Application is single binary(linux amd64 default), you can just download from latest release and run it.\nRunning:\nwget https://github.com/emiago/diagox/releases/latest/download/diagox chmox +x diagox ./diagox or you can use docker image:\ndocker run --rm -it emiago/diagox # With mounting config docker run --rm -it emiago/diagox -v $(pwd)/diagox.yaml:/app/diagox.yaml For other archs plese check on latest releases","configuration#Configuration":"Configuration is simple based on yaml. This offers higher automation and easier managing. You define transport,endpoints and routes in configuration. Here is sample of almost all possible current configurations:\ndiagox.yaml\nversion: \"2.4\" # transports for SIP transports: udp: transport: \"udp\" bind: 0.0.0.0 port: 5060 external_host: my.domain.com # Use env SIP_EXTERNAL_HOST to set for all transports external_media_ip: 1.2.3.4 # Use env SIP_EXTERNAL_MEDIA_IP to set for all transports tcp: transport: \"tcp\" bind: 0.0.0.0 port: 5060 udp_local: transport: \"udp\" bind: 127.0.0.1 port: 5099 # Secure WebSocket for WEBRTC Users # TLS Configuration is done with envirment configuration. Checkout SERVER_TLS_* env variables wss: transport: \"wss\" bind: 0.0.0.0 port: 5443 # routes allow you to customize which endpoint your number should reach # - `default` route context is special one which is always used unless incoming endpoint did not override # - you can create more routes and split logic as you like # - keeping route context small can improve call route matching routes: # Default context goes every call from all endpoints # If not created or overided it has this configuration default: - id: \"\" match: \"any\" # Match any number use_registry: true # Check registry. Any register user will be reached incoming: # Order here matters # Required fields are: id and endpoint # Example with strict number matching - id: \"4912345678\" endpoint: carrier_internal # On which endpoint to send # Example with prefix matching - id: \"381\" match: prefix endpoint: carrier_internal # Example with prefix matching and passing SIP headers - id: \"121\" match: prefix endpoint: carrier_internal sip_headers_pass: [\"X-Myheader\", \"X-Account-ID\"] # This headers are copied from incoming call to outgoing sip_headers: # This headers are added on outgoing channel. X-Fixed-Header: \"Call121\" # Example of outgoing where you want to have your internal endpoint route calls out outgoing: - id: \"987\" match: \"prefix\" endpoint: carrier_external # Example where to match all if did not match any of previous # Instead of endpoint we just want to hangup call. This is where hangup module is provided - id: \"\" match: \"any\" #Match all hangup: code: 404 # Example when you want to route call but also do some fallback if initial endpoint/carrier failed with_fallback: - id: 49 # Match all outgoing german numbers match: \"prefix\" endpoint: carrier_external fallback: codes: [401, 404, 487] endpoints: [\"carrier_external_fallback_1\", \"carrier_external_fallback_2\"] # Example of when you want to route call to your Agents over RPC protocol with_agent_rpc_control: - id: \"888\" match: \"prefix\" endpoint: \"agent_rpc_endpoint\" # Endpoints define way to identify your incoming SIP traffic and which route to use. # Identifing is done with `match`. Supported values are: ip, user # - `ip` is your incoming source IP # - `user` matches by SIP From header and USER property ex. From: \u003csip:$USER@example.com\u003e # Match order is: user, ip endpoints: carrier_external: route: incoming match: type: \"ip\" values: [\"182.168.0.0/24\"] # Auth will identify incoming SIP INVITE/REGISTER additionally with Digest authentication auth: username: \"test\" password: \"test123\" # Uri is for your outgoing or how to reach this carrier. # If you use this endpoint in routes, this SIP uri will be used to reach. User part is replaced by caller ID. uri: \"sip:carrier.external.com:5080\" transport: tcp # You can force which transport to use. This is id of transport defined in transports carrier_internal: # When matched call will be sent to outgoing route route: outgoing # Incoming options match: type: \"ip\" values: [\"127.0.0.1/8\"] # Using many carrier fallback endpoints carrier_external_fallback_1: carrier_external_fallback_2: alice: # routing: default # If not defined `default`` route is used match: type: \"user\" auth: username: \"alice\" password: \"test123\" bob: match: type: \"user\" auth: username: \"carrier\" password: \"test123\" # Example of WEBRTC User Endpoint Configuration # normally you want to have WS(Websocket) endpoint configured for SIP. webrtc: match: type: \"user\" auth: username: \"webrtc\" password: \"webrtc\" media: type: \"webrtc\" # USE WEBRTC media stack instead standard! # Agent RPC Framework requires endpoint that is type of Agent # Any call landing on this endpoint will be forwarded to AGENT Connected on this endpoint # Endpoint name is ID for Agent that will be used when connecting agent_rpc_endpoint: match: type: \"agent ","global-configuration#Global configuration":"Diagox uses env vars for more easier provision of some global configuration, specially in case running in container envs. Although this could be part of yaml, changing env var is generally eaiser and faster way to handle.\n// Log formating. string \"LOG_LEVEL\" envDefault:\"info\" // debug, info, warn, error string \"LOG_FORMAT\" envDefault:\"console\" // json, console // Rate limiting for incoming and outgoing bool \"RATE_LIMITER_IN_ENABLED\" envDefault:\"false\" int64 \"RATE_LIMITER_IN_DIALOG_RPS\" int64 \"RATE_LIMITER_IN_DIALOG_MAX\" bool \"RATE_LIMITER_OUT_ENABLED\" envDefault:\"false\" int64 \"RATE_LIMITER_OUT_DIALOG_RPS\" // SIP based string \"SIP_BIND_IP\" envDefault:\"\" // Useful for pods/nodes that have dedicated IP string \"SIP_EXTERNAL_IP\" envDefault:\"\" // Useful for pods/nodes that have dedicated IP string \"SIP_HOSTNAME\" envDefault:\"\" // SIP_HOSTNAME identifies that message are matching this hostname. Used in registrar for example string \"OUTBOUND_DIAL_URI\" envDefault:\"sip:test@127.0.0.222:5066\" // OUTBOUND_DIAL_URI is default outbound dial uri if not defined by endpoint // SIP SERVER TLS configuration string \"SERVER_TLS_KEY\" envDefault:\"\" // Base64 encoded key string \"SERVER_TLS_CRT\" envDefault:\"\" // Base64 encoded crt string \"SERVER_TLS_KEY_PATH\" envDefault:\"\" string \"SERVER_TLS_CRT_PATH\" envDefault:\"\" // Misc string \"CONF_FILE\" envDefault:\"diagox.yaml\" bool \"CDR_ENABLE\" envDefault:\"true\" string \"RECORDINGS_PATH\" envDefault:\"recordings\" bool \"FRONTEND_ENABLE\" envDefault:\"false\" ","gui#GUI":"Diagox has web interface and you need to enable it with env var\nFRONTEND_ENABLE=true ./diagox It is exposed by default on :6060.","multi-node-cluster-wip#Multi node (Cluster) (WIP)":" TODO"},"title":"Install"},"/diagox/docs/webrtc/":{"data":{"":"Diagox allows you to handle WebRTC clients that talk SIP and bridge with standard VOIP services without handling this on your side.\nIt is important that you have Websocket transport for SIP defined and endpoint that has media type of webrtc.\ntransports: # Secure WebSocket for WEBRTC Users. # TLS Configuration is done with envirment configuration. Checkout SERVER_TLS_* env variables wss: transport: \"wss\" bind: 0.0.0.0 port: 5443 endpoints: # Example of WEBRTC User Endpoint Configuration # normally you want to have WS(Websocket) endpoint configured for SIP. webrtc: match: type: \"user\" auth: username: \"webrtc\" password: \"webrtc\" media: type: \"webrtc\" # USE WEBRTC media stack instead standard! "},"title":"WebRTC"}}